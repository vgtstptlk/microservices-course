# Операционные системы

## Лекция 1. Введение

### Эволюция ЭВМ

Факторы отбора

- Эффективность 
- Удобность 
- Безопасность хранения 

Первые электронные вычислительные машины появились после 2 мировой войны (1945-1955г).

В середине 1945г одновременно с созданием ламповых ВМ, формулирутеся принцип хранимости программ в памяти. **Принцип Фон-Неймана.**  

Ввод программ осуществляется через пефрокарты или через пульты. Отладка системы происходит с помощью тех же людей, которые вводили программу. 

В 1951-1952 году появляется первый компилятор Фортрана. В 1954 году появляется ассемблер для IBM 701. Надо отметить, что в то время машина могла выполнять одновременно только одну операцию. По сути дела, это просто научно-исследовательская работа, а не реальный проект. 

В начале 50-ых появляются полупроводниковые элементы -- транзисторы. На транзисторах строятся более совершенные ВТ. Наступает второй этап развития ВТ с 1955 до 1960-ых. 

Поялвяется все больше языков программирования. В десятки раз больше языков программирования. Программировать становится проще, и поэтому происходит разделение персонала. В результате этого появляется возможность использования ВТ в коммерции. Начинается счет первых практических задач. 

Для ускорения прогонки задач начали составлять пакеты заданий. Появляются первые спецализированные пакетные прогонщики, первое системное программное обеспечение. 

В начале 60-ых годов происходит новый скачок в hardware. От отдельных полупроводниковых элементов переходят к интегральным схемам. Сдерживающим фактором оставалось наличие периферии. 

Внедрение мультипрограммности привело целой революции к построению ВТ. До поялвения идеи мультипрограммирования в ОЗУ хранилась только одна программа. Когда происходит ввод или вывод процессор выполняет сторонные программы, а когда вывод или ввод заканчивается процесор возвращается рассчитывать.

Для мультипрограммности необходимо реализовать деление памяти. 

Планирование использрвания процессора -- **планировщик использования процесса**. 

**Функции ОС выполняют**:

- Планирование заданий и использование процессора 
- Обеспечение санкционированного взаимодействия программ, предоставления программ средств коммуникации и синхронизации
- Управление паматью 
- Управление файловых систем 
- Управление вводом-выводом 
- Обеспечение безопасности работы пользователей и различных программ  

**Основные виды ОС по их строению:**

- Строение с монолитным ядром (единый блок скомпилированного кода из процедур). Ядро == всей ОС. Даже в монолитной системе есть системные вызовы. 
- Разделение ОС на несколько уровней, которые выполняет свои задачи. Причем N-ый уровень может вызвать только N-1 уровень. Первая такая система -- THE.  Все уровни, кроме пользовательского, имеют привилегированный уровень. 
- Микроядерная архитектура. Попытка сделать ядро минимального размера, и только ядро будет работать в привилегированном режиме, а остальное оставить на пользовательский режим. Ядро и другие части ОС взаимодейтсвует с помощью передачи информации. К сожалению, микроядерная архитектура резко снижает скорость работы. Но есть решение этого, сделать ядро еще меньше, оставив только функции обработки прерываний и передачи сообщений. Такие системы получили название наносистем. 

Каждая архитектура имеет свои недостатки и достоинства:

- Строение с монолитным ядром, например, при изменении конфигурации требует полной перекомпиляции, очень большие размеры ядра, но крайне высокая скорость работы. 
- Многоуровневую тоже необходимо перекомпилировать, но отлаживать только измененный уровень. Скорость работы становится меньше. 
- Микроядерная архитектура -- изумительная идея, легко реализуется, легко отлаживается, но очень медленные. 

Именно поэтому встречаются системы с комбинированными архитектурами. 

## Лекция 2. Процессы

**Программа** -- совокупность некотрых файлов 

**Задание** -- те же файлы + данные, которые будут использоваться для вычисления 

Для описания программ в момент их выполнения нужно ввести новый термин / абстракцию -- **процесс**. Этот термин является основполагающим в теории ОС. 

Термин **Процесс** используется для описания динамических/активных объектов (что находится в ОЗУ в момент выполнения).  

**Процесс** -- программа во время выполнения (неверное определение).

Когда программа исполняется ОС должна отвести этой программе какое-то адрессное место, куда будет занесен программный код и данные для этой программы. 

**Процесс** -- совокупность команд исполняемого кода, ресурсов, которые приписаны этому набору команд (устройства ввода/вывода, память и т. д.) и текущего момента исполнения. Вся эта совокупность должна находиться под управлением ОС. 

ОС можно описать как совокупность нескольких процессов. Процессы могут быть пользовательские, операционной системы. 

Пока в нашей модели у процесса может быть только 2 положения: процесс исполняется, процесс не исполняется. 

Процесс исполняется -- он имеет процессор 

Процесс не исполняется -- он загружен в ОЗУ, но не обладаеи процессором. 

​	Процессы готовые к исполнению

​	Процессы ожидания 



Еще есть 2 состояние процесса 

Процесс рождается

Процесс умирает



